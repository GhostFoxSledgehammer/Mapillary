<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapillaryLayer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapillary</a> &gt; <a href="index.source.html" class="el_package">org.openstreetmap.josm.plugins.mapillary</a> &gt; <span class="el_source">MapillaryLayer.java</span></div><h1>MapillaryLayer.java</h1><pre class="source lang-java linenums">// License: GPL. For details, see LICENSE file.
package org.openstreetmap.josm.plugins.mapillary;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.TexturePaint;
import java.awt.event.ActionEvent;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.image.BufferedImage;
import java.util.Comparator;
import java.util.IntSummaryStatistics;
import java.util.Optional;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.Icon;
import javax.swing.JComponent;
import javax.swing.KeyStroke;

import org.openstreetmap.josm.Main;
import org.openstreetmap.josm.data.Bounds;
import org.openstreetmap.josm.data.osm.DataSet;
import org.openstreetmap.josm.data.osm.event.DataChangedEvent;
import org.openstreetmap.josm.data.osm.event.DataSetListenerAdapter;
import org.openstreetmap.josm.data.osm.visitor.BoundingXYVisitor;
import org.openstreetmap.josm.gui.MainApplication;
import org.openstreetmap.josm.gui.MapView;
import org.openstreetmap.josm.gui.NavigatableComponent;
import org.openstreetmap.josm.gui.dialogs.LayerListDialog;
import org.openstreetmap.josm.gui.dialogs.LayerListPopup;
import org.openstreetmap.josm.gui.layer.AbstractModifiableLayer;
import org.openstreetmap.josm.gui.layer.Layer;
import org.openstreetmap.josm.gui.layer.LayerManager;
import org.openstreetmap.josm.gui.layer.MainLayerManager.ActiveLayerChangeEvent;
import org.openstreetmap.josm.gui.layer.MainLayerManager.ActiveLayerChangeListener;
import org.openstreetmap.josm.plugins.mapillary.cache.CacheUtils;
import org.openstreetmap.josm.plugins.mapillary.gui.MapillaryChangesetDialog;
import org.openstreetmap.josm.plugins.mapillary.gui.MapillaryFilterDialog;
import org.openstreetmap.josm.plugins.mapillary.gui.MapillaryMainDialog;
import org.openstreetmap.josm.plugins.mapillary.history.MapillaryRecord;
import org.openstreetmap.josm.plugins.mapillary.history.commands.CommandDelete;
import org.openstreetmap.josm.plugins.mapillary.io.download.MapillaryDownloader;
import org.openstreetmap.josm.plugins.mapillary.io.download.MapillaryDownloader.DOWNLOAD_MODE;
import org.openstreetmap.josm.plugins.mapillary.mode.AbstractMode;
import org.openstreetmap.josm.plugins.mapillary.mode.JoinMode;
import org.openstreetmap.josm.plugins.mapillary.mode.SelectMode;
import org.openstreetmap.josm.plugins.mapillary.utils.MapViewGeometryUtil;
import org.openstreetmap.josm.plugins.mapillary.utils.MapillaryColorScheme;
import org.openstreetmap.josm.plugins.mapillary.utils.MapillaryProperties;
import org.openstreetmap.josm.plugins.mapillary.utils.MapillaryUtils;
import org.openstreetmap.josm.tools.I18n;
import org.openstreetmap.josm.tools.ImageProvider.ImageSizes;
import org.openstreetmap.josm.tools.Logging;

/**
 * This class represents the layer shown in JOSM. There can only exist one
 * instance of this object.
 *
 * @author nokutu
 */
public final class MapillaryLayer extends AbstractModifiableLayer implements
  ActiveLayerChangeListener, MapillaryDataListener {

  /** Maximum distance for the red/blue lines. */
<span class="fc" id="L73">  public static final int SEQUENCE_MAX_JUMP_DISTANCE = MapillaryProperties.SEQUENCE_MAX_JUMP_DISTANCE.get();</span>

  /** The radius of the image marker */
  private static final int IMG_MARKER_RADIUS = 7;
  /** The radius of the circular sector that indicates the camera angle */
  private static final int CA_INDICATOR_RADIUS = 15;
  /** The angle of the circular sector that indicates the camera angle */
  private static final int CA_INDICATOR_ANGLE = 40;
  /** Length of the edge of the small sign, which indicates that traffic signs have been found in an image. */
  private static final int TRAFFIC_SIGN_SIZE = 6;
  /** A third of the height of the sign, for easier calculations */
<span class="fc" id="L84">  private static final double TRAFFIC_SIGN_HEIGHT_3RD = Math.sqrt(</span>
<span class="fc" id="L85">    Math.pow(TRAFFIC_SIGN_SIZE, 2) - Math.pow(TRAFFIC_SIGN_SIZE / 2d, 2)</span>
  ) / 3;

<span class="fc" id="L88">  private static final DataSetListenerAdapter DATASET_LISTENER =</span>
    new DataSetListenerAdapter(e -&gt; {
<span class="nc bnc" id="L90" title="All 4 branches missed.">      if (e instanceof DataChangedEvent &amp;&amp; MapillaryDownloader.getMode() == DOWNLOAD_MODE.OSM_AREA) {</span>
        // When more data is downloaded, a delayed update is thrown, in order to
        // wait for the data bounds to be set.
<span class="nc" id="L93">        MainApplication.worker.execute(()-&gt; MapillaryDownloader.downloadOSMArea());</span>
      }
<span class="nc" id="L95">    });</span>

  /** If the download is in semiautomatic during this object lifetime. */
  public boolean tempSemiautomatic;

  /** Unique instance of the class. */
  private static MapillaryLayer instance;
  /** The nearest images to the selected image from different sequences sorted by distance from selection. */
<span class="fc" id="L103">  private MapillaryImage[] nearestImages = {};</span>
  /** {@link MapillaryData} object that stores the database. */
  private final MapillaryData data;

  /** Mode of the layer. */
  public AbstractMode mode;

  private volatile TexturePaint hatched;
<span class="fc" id="L111">  private final MapillaryLocationChangeset locationChangeset = new MapillaryLocationChangeset();</span>

  private MapillaryLayer() {
<span class="fc" id="L114">    super(I18n.tr(&quot;Mapillary Images&quot;));</span>
<span class="fc" id="L115">    this.data = new MapillaryData();</span>
<span class="fc" id="L116">    data.addListener(this);</span>
<span class="fc" id="L117">  }</span>

  /**
   * Initializes the Layer.
   */
  private void init() {
<span class="fc" id="L123">    final DataSet ds = MainApplication.getLayerManager().getEditDataSet();</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">    if (ds != null) {</span>
<span class="nc" id="L125">      ds.addDataSetListener(DATASET_LISTENER);</span>
    }
<span class="fc" id="L127">    MainApplication.getLayerManager().addLayer(this);</span>
<span class="fc" id="L128">    MainApplication.getLayerManager().addActiveLayerChangeListener(this);</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="fc" id="L130">      setMode(new SelectMode());</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">      if (MapillaryDownloader.getMode() == DOWNLOAD_MODE.OSM_AREA) {</span>
<span class="fc" id="L132">        MapillaryDownloader.downloadOSMArea();</span>
      }
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">      if (MapillaryDownloader.getMode() == DOWNLOAD_MODE.VISIBLE_AREA) {</span>
<span class="nc" id="L135">        this.mode.zoomChanged();</span>
      }
    }
    // Does not execute when in headless mode
<span class="pc bpc" id="L139" title="1 of 4 branches missed.">    if (Main.main != null &amp;&amp; !MapillaryMainDialog.getInstance().isShowing()) {</span>
<span class="fc" id="L140">      MapillaryMainDialog.getInstance().showDialog();</span>
    }
<span class="fc bfc" id="L142" title="All 2 branches covered.">    if (MapillaryPlugin.getMapView() != null) {</span>
<span class="fc" id="L143">      MapillaryMainDialog.getInstance().mapillaryImageDisplay.repaint();</span>
<span class="fc" id="L144">      MapillaryMainDialog.getInstance()</span>
<span class="fc" id="L145">        .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)</span>
<span class="fc" id="L146">        .put(KeyStroke.getKeyStroke(&quot;DELETE&quot;), &quot;MapillaryDel&quot;);</span>
<span class="fc" id="L147">      MapillaryMainDialog.getInstance().getActionMap()</span>
<span class="fc" id="L148">        .put(&quot;MapillaryDel&quot;, new DeleteImageAction());</span>

<span class="fc" id="L150">      getLocationChangeset().addChangesetListener(MapillaryChangesetDialog.getInstance());</span>
    }
<span class="fc" id="L152">    createHatchTexture();</span>
<span class="fc" id="L153">    invalidate();</span>
<span class="fc" id="L154">  }</span>

  public static void invalidateInstance() {
<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (hasInstance()) {</span>
<span class="fc" id="L158">      getInstance().invalidate();</span>
    }
<span class="fc" id="L160">  }</span>

  /**
   * Changes the mode the the given one.
   *
   * @param mode The mode that is going to be activated.
   */
  public void setMode(AbstractMode mode) {
<span class="fc" id="L168">    final MapView mv = MapillaryPlugin.getMapView();</span>
<span class="pc bpc" id="L169" title="1 of 4 branches missed.">    if (this.mode != null &amp;&amp; mv != null) {</span>
<span class="fc" id="L170">      mv.removeMouseListener(this.mode);</span>
<span class="fc" id="L171">      mv.removeMouseMotionListener(this.mode);</span>
<span class="fc" id="L172">      NavigatableComponent.removeZoomChangeListener(this.mode);</span>
    }
<span class="fc" id="L174">    this.mode = mode;</span>
<span class="fc bfc" id="L175" title="All 4 branches covered.">    if (mode != null &amp;&amp; mv != null) {</span>
<span class="fc" id="L176">      mv.setNewCursor(mode.cursor, this);</span>
<span class="fc" id="L177">      mv.addMouseListener(mode);</span>
<span class="fc" id="L178">      mv.addMouseMotionListener(mode);</span>
<span class="fc" id="L179">      NavigatableComponent.addZoomChangeListener(mode);</span>
<span class="fc" id="L180">      MapillaryUtils.updateHelpText();</span>
    }
<span class="fc" id="L182">  }</span>

  private static synchronized void clearInstance() {
<span class="fc" id="L185">    instance = null;</span>
<span class="fc" id="L186">  }</span>

  /**
   * Returns the unique instance of this class.
   *
   * @return The unique instance of this class.
   */
  public static synchronized MapillaryLayer getInstance() {
<span class="fc bfc" id="L194" title="All 2 branches covered.">    if (instance != null) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">      if (!MainApplication.getLayerManager().containsLayer(instance)) {</span>
<span class="fc" id="L196">        MainApplication.getLayerManager().addLayer(instance);</span>
      }
<span class="fc" id="L198">      return instance;</span>
    }
<span class="fc" id="L200">    final MapillaryLayer layer = new MapillaryLayer();</span>
<span class="fc" id="L201">    instance = layer;</span>
<span class="fc" id="L202">    layer.init();</span>
<span class="fc" id="L203">    return layer;</span>
  }

  /**
   * @return if the unique instance of this layer is currently instantiated and added to the {@link LayerManager}
   */
  public static boolean hasInstance() {
<span class="fc bfc" id="L210" title="All 4 branches covered.">    return instance != null &amp;&amp; MainApplication.getLayerManager().containsLayer(instance);</span>
  }

  /**
   * Returns the {@link MapillaryData} object, which acts as the database of the
   * Layer.
   *
   * @return The {@link MapillaryData} object that stores the database.
   */
  public MapillaryData getData() {
<span class="fc" id="L220">    return this.data;</span>
  }

  /**
   * Returns the {@link MapillaryLocationChangeset} object, which acts as the database of the
   * Layer.
   *
   * @return The {@link MapillaryData} object that stores the database.
   */
  public MapillaryLocationChangeset getLocationChangeset() {
<span class="fc" id="L230">    return locationChangeset;</span>
  }

  /**
   * Returns the n-nearest image, for n=1 the nearest one is returned, for n=2 the second nearest one and so on.
   * The &quot;n-nearest image&quot; is picked from the list of one image from every sequence that is nearest to the currently
   * selected image, excluding the sequence to which the selected image belongs.
   * @param n the index for picking from the list of &quot;nearest images&quot;, beginning from 1
   * @return the n-nearest image to the currently selected image
   */
  public synchronized MapillaryImage getNNearestImage(final int n) {
<span class="nc bnc" id="L241" title="All 4 branches missed.">    return n &gt;= 1 &amp;&amp; n &lt;= nearestImages.length ? nearestImages[n - 1] : null;</span>
  }

  @Override
  public synchronized void destroy() {
<span class="fc" id="L246">    clearInstance();</span>
<span class="fc" id="L247">    setMode(null);</span>
<span class="fc" id="L248">    MapillaryRecord.getInstance().reset();</span>
<span class="fc" id="L249">    AbstractMode.resetThread();</span>
<span class="fc" id="L250">    MapillaryDownloader.stopAll();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">    if (MapillaryMainDialog.hasInstance()) {</span>
<span class="fc" id="L252">      MapillaryMainDialog.getInstance().setImage(null);</span>
<span class="fc" id="L253">      MapillaryMainDialog.getInstance().updateImage();</span>
    }
<span class="fc" id="L255">    final MapView mv = MapillaryPlugin.getMapView();</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    if (mv != null) {</span>
<span class="fc" id="L257">      mv.removeMouseListener(this.mode);</span>
<span class="fc" id="L258">      mv.removeMouseMotionListener(this.mode);</span>
    }
    try {
<span class="fc" id="L261">      MainApplication.getLayerManager().removeActiveLayerChangeListener(this);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">      if (MainApplication.getLayerManager().getEditDataSet() != null) {</span>
<span class="nc" id="L263">        MainApplication.getLayerManager().getEditDataSet().removeDataSetListener(DATASET_LISTENER);</span>
      }
<span class="fc" id="L265">    } catch (IllegalArgumentException e) {</span>
      // TODO: It would be ideal, to fix this properly. But for the moment let's catch this, for when a listener has already been removed.
<span class="fc" id="L267">    }</span>
<span class="fc" id="L268">    super.destroy();</span>
<span class="fc" id="L269">  }</span>

  @Override
  public boolean isModified() {
<span class="nc" id="L273">    return this.data.getImages().parallelStream().anyMatch(MapillaryAbstractImage::isModified);</span>
  }

  @Override
  public void setVisible(boolean visible) {
<span class="fc" id="L278">    super.setVisible(visible);</span>
<span class="fc" id="L279">    getData().getImages().parallelStream().forEach(img -&gt; img.setVisible(visible));</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">    if (MainApplication.getMap() != null) {</span>
<span class="fc" id="L281">      MapillaryFilterDialog.getInstance().refresh();</span>
    }
<span class="fc" id="L283">  }</span>

  /**
   * Initialize the hatch pattern used to paint the non-downloaded area.
   */
  private void createHatchTexture() {
<span class="fc" id="L289">    BufferedImage bi = new BufferedImage(15, 15, BufferedImage.TYPE_INT_ARGB);</span>
<span class="fc" id="L290">    Graphics2D big = bi.createGraphics();</span>
<span class="fc" id="L291">    big.setColor(MapillaryProperties.BACKGROUND.get());</span>
<span class="fc" id="L292">    Composite comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f);</span>
<span class="fc" id="L293">    big.setComposite(comp);</span>
<span class="fc" id="L294">    big.fillRect(0, 0, 15, 15);</span>
<span class="fc" id="L295">    big.setColor(MapillaryProperties.OUTSIDE_DOWNLOADED_AREA.get());</span>
<span class="fc" id="L296">    big.drawLine(0, 15, 15, 0);</span>
<span class="fc" id="L297">    Rectangle r = new Rectangle(0, 0, 15, 15);</span>
<span class="fc" id="L298">    this.hatched = new TexturePaint(bi, r);</span>
<span class="fc" id="L299">  }</span>

  @Override
  public synchronized void paint(final Graphics2D g, final MapView mv, final Bounds box) {
<span class="nc" id="L303">    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (MainApplication.getLayerManager().getActiveLayer() == this) {</span>
      // paint remainder
<span class="nc" id="L306">      g.setPaint(this.hatched);</span>
<span class="nc" id="L307">      g.fill(MapViewGeometryUtil.getNonDownloadedArea(mv, this.data.getBounds()));</span>
    }

    // Draw the blue and red line
<span class="nc" id="L311">    synchronized (MapillaryLayer.class) {</span>
<span class="nc" id="L312">      final MapillaryAbstractImage selectedImg = data.getSelectedImage();</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">      for (int i = 0; i &lt; nearestImages.length &amp;&amp; selectedImg != null; i++) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (i == 0) {</span>
<span class="nc" id="L315">          g.setColor(Color.RED);</span>
        } else {
<span class="nc" id="L317">          g.setColor(Color.BLUE);</span>
        }
<span class="nc" id="L319">        final Point selected = mv.getPoint(selectedImg.getMovingLatLon());</span>
<span class="nc" id="L320">        final Point p = mv.getPoint(nearestImages[i].getMovingLatLon());</span>
<span class="nc" id="L321">        g.draw(new Line2D.Double(p.getX(), p.getY(), selected.getX(), selected.getY()));</span>
      }
<span class="nc" id="L323">    }</span>

    // Draw sequence line
<span class="nc" id="L326">    g.setStroke(new BasicStroke(2));</span>
<span class="nc" id="L327">    final MapillaryAbstractImage selectedImage = getData().getSelectedImage();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">    for (MapillarySequence seq : getData().getSequences()) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">      if (seq.getImages().contains(selectedImage)) {</span>
<span class="nc" id="L330">        g.setColor(</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">          seq.getKey() == null ? MapillaryColorScheme.SEQ_IMPORTED_SELECTED : MapillaryColorScheme.SEQ_SELECTED</span>
        );
      } else {
<span class="nc" id="L334">        g.setColor(</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">          seq.getKey() == null ? MapillaryColorScheme.SEQ_IMPORTED_UNSELECTED : MapillaryColorScheme.SEQ_UNSELECTED</span>
        );
      }
<span class="nc" id="L338">      g.draw(MapViewGeometryUtil.getSequencePath(mv, seq));</span>
<span class="nc" id="L339">    }</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">    for (MapillaryAbstractImage imageAbs : this.data.getImages()) {</span>
<span class="nc bnc" id="L341" title="All 6 branches missed.">      if (imageAbs.isVisible() &amp;&amp; mv != null &amp;&amp; mv.contains(mv.getPoint(imageAbs.getMovingLatLon()))) {</span>
<span class="nc" id="L342">        drawImageMarker(g, imageAbs);</span>
      }
<span class="nc" id="L344">    }</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    if (this.mode instanceof JoinMode) {</span>
<span class="nc" id="L346">      this.mode.paint(g, mv, box);</span>
    }
<span class="nc" id="L348">  }</span>

  /**
   * Draws an image marker onto the given Graphics context.
   * @param g the Graphics context
   * @param img the image to be drawn onto the Graphics context
   */
  private void drawImageMarker(final Graphics2D g, final MapillaryAbstractImage img) {
<span class="nc bnc" id="L356" title="All 4 branches missed.">    if (img == null || img.getLatLon() == null) {</span>
<span class="nc" id="L357">      Logging.warn(&quot;An image is not painted, because it is null or has no LatLon!&quot;);</span>
<span class="nc" id="L358">      return;</span>
    }
<span class="nc" id="L360">    final MapillaryAbstractImage selectedImg = getData().getSelectedImage();</span>
<span class="nc" id="L361">    final Point p = MainApplication.getMap().mapView.getPoint(img.getMovingLatLon());</span>

    // Determine colors
    final Color markerC;
    final Color directionC;
<span class="nc bnc" id="L366" title="All 4 branches missed.">    if (selectedImg != null &amp;&amp; getData().getMultiSelectedImages().contains(img)) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">      markerC = img instanceof MapillaryImportedImage</span>
<span class="nc" id="L368">        ? MapillaryColorScheme.SEQ_IMPORTED_HIGHLIGHTED</span>
<span class="nc" id="L369">        : MapillaryColorScheme.SEQ_HIGHLIGHTED;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">      directionC = img instanceof MapillaryImportedImage</span>
<span class="nc" id="L371">        ? MapillaryColorScheme.SEQ_IMPORTED_HIGHLIGHTED_CA</span>
<span class="nc" id="L372">        : MapillaryColorScheme.SEQ_HIGHLIGHTED_CA;</span>
<span class="nc bnc" id="L373" title="All 6 branches missed.">    } else if (selectedImg != null &amp;&amp; selectedImg.getSequence() != null &amp;&amp; selectedImg.getSequence().equals(img.getSequence())) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">      markerC = img instanceof MapillaryImportedImage</span>
<span class="nc" id="L375">        ? MapillaryColorScheme.SEQ_IMPORTED_SELECTED</span>
<span class="nc" id="L376">        : MapillaryColorScheme.SEQ_SELECTED;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      directionC = img instanceof MapillaryImportedImage</span>
<span class="nc" id="L378">        ? MapillaryColorScheme.SEQ_IMPORTED_SELECTED_CA</span>
<span class="nc" id="L379">        : MapillaryColorScheme.SEQ_SELECTED_CA;</span>
    } else {
<span class="nc bnc" id="L381" title="All 2 branches missed.">      markerC = img instanceof MapillaryImportedImage</span>
<span class="nc" id="L382">        ? MapillaryColorScheme.SEQ_IMPORTED_UNSELECTED</span>
<span class="nc" id="L383">        : MapillaryColorScheme.SEQ_UNSELECTED;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">      directionC = img instanceof MapillaryImportedImage</span>
<span class="nc" id="L385">        ? MapillaryColorScheme.SEQ_IMPORTED_UNSELECTED_CA</span>
<span class="nc" id="L386">        : MapillaryColorScheme.SEQ_UNSELECTED_CA;</span>
    }

    // Paint direction indicator
<span class="nc" id="L390">    g.setColor(directionC);</span>
<span class="nc" id="L391">    g.fillArc(p.x - CA_INDICATOR_RADIUS, p.y - CA_INDICATOR_RADIUS, 2 * CA_INDICATOR_RADIUS, 2 * CA_INDICATOR_RADIUS, (int) (90 - img.getMovingCa() - CA_INDICATOR_ANGLE / 2d), CA_INDICATOR_ANGLE);</span>
    // Paint image marker
<span class="nc" id="L393">    g.setColor(markerC);</span>
<span class="nc" id="L394">    g.fillOval(p.x - IMG_MARKER_RADIUS, p.y - IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS);</span>

    // Paint highlight for selected or highlighted images
<span class="nc bnc" id="L397" title="All 4 branches missed.">    if (img.equals(getData().getHighlightedImage()) || getData().getMultiSelectedImages().contains(img)) {</span>
<span class="nc" id="L398">      g.setColor(Color.WHITE);</span>
<span class="nc" id="L399">      g.setStroke(new BasicStroke(2));</span>
<span class="nc" id="L400">      g.drawOval(p.x - IMG_MARKER_RADIUS, p.y - IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS);</span>
    }


<span class="nc bnc" id="L404" title="All 4 branches missed.">    if (img instanceof MapillaryImage &amp;&amp; !((MapillaryImage) img).getDetections().isEmpty()) {</span>
<span class="nc" id="L405">      Path2D trafficSign = new Path2D.Double();</span>
<span class="nc" id="L406">      trafficSign.moveTo(p.getX() - TRAFFIC_SIGN_SIZE / 2d, p.getY() - TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L407">      trafficSign.lineTo(p.getX() + TRAFFIC_SIGN_SIZE / 2d, p.getY() - TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L408">      trafficSign.lineTo(p.getX(), p.getY() + 2 * TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L409">      trafficSign.closePath();</span>
<span class="nc" id="L410">      g.setColor(Color.WHITE);</span>
<span class="nc" id="L411">      g.fill(trafficSign);</span>
<span class="nc" id="L412">      g.setStroke(new BasicStroke(1));</span>
<span class="nc" id="L413">      g.setColor(Color.RED);</span>
<span class="nc" id="L414">      g.draw(trafficSign);</span>
    }
<span class="nc" id="L416">  }</span>

  @Override
  public Icon getIcon() {
<span class="fc" id="L420">    return MapillaryPlugin.LOGO.setSize(ImageSizes.LAYER).get();</span>
  }

  @Override
  public boolean isMergable(Layer other) {
<span class="fc" id="L425">    return false;</span>
  }

  @Override
  public void mergeFrom(Layer from) {
<span class="fc" id="L430">    throw new UnsupportedOperationException(</span>
      &quot;This layer does not support merging yet&quot;);
  }

  @Override
  public Action[] getMenuEntries() {
<span class="nc" id="L436">    return new Action[]{</span>
<span class="nc" id="L437">      LayerListDialog.getInstance().createShowHideLayerAction(),</span>
<span class="nc" id="L438">      LayerListDialog.getInstance().createDeleteLayerAction(),</span>
      new LayerListPopup.InfoAction(this)
    };
  }

  @Override
  public Object getInfoComponent() {
<span class="pc" id="L445">    IntSummaryStatistics seqSizeStats = getData().getSequences().stream().mapToInt(seq -&gt; seq.getImages().size()).summaryStatistics();</span>
<span class="fc" id="L446">    return new StringBuilder(I18n.tr(&quot;Mapillary layer&quot;))</span>
<span class="fc" id="L447">      .append(&quot;\n&quot;)</span>
<span class="fc" id="L448">      .append(I18n.tr(</span>
        &quot;{0} sequences, each containing between {1} and {2} images (ø {3})&quot;,
<span class="fc" id="L450">        getData().getSequences().size(),</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        seqSizeStats.getCount() &lt;= 0 ? 0 : seqSizeStats.getMin(),</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        seqSizeStats.getCount() &lt;= 0 ? 0 : seqSizeStats.getMax(),</span>
<span class="fc" id="L453">        seqSizeStats.getAverage()</span>
      ))
<span class="fc" id="L455">      .append(&quot;\n\n&quot;)</span>
<span class="fc" id="L456">      .append(I18n.tr(</span>
        &quot;{0} imported images&quot;,
<span class="pc" id="L458">        getData().getImages().stream().filter(i -&gt; i instanceof MapillaryImportedImage).count()</span>
      ))
<span class="fc" id="L460">      .append(&quot;\n+ &quot;)</span>
<span class="fc" id="L461">      .append(I18n.tr(</span>
        &quot;{0} downloaded images&quot;,
<span class="pc" id="L463">        getData().getImages().stream().filter(i -&gt; i instanceof MapillaryImage).count()</span>
      ))
<span class="fc" id="L465">      .append(&quot;\n= &quot;)</span>
<span class="fc" id="L466">      .append(I18n.tr(</span>
        &quot;{0} images in total&quot;,
<span class="fc" id="L468">        getData().getImages().size()</span>
<span class="fc" id="L469">      )).toString();</span>
  }

  @Override
  public String getToolTipText() {
<span class="nc" id="L474">    return I18n.tr(&quot;{0} images in {1} sequences&quot;, getData().getImages().size(), getData().getSequences().size());</span>
  }

  @Override
  public void activeOrEditLayerChanged(ActiveLayerChangeEvent e) {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">    if (MainApplication.getLayerManager().getActiveLayer() == this) {</span>
<span class="nc" id="L480">      MapillaryUtils.updateHelpText();</span>
    }

<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (MainApplication.getLayerManager().getEditLayer() != e.getPreviousEditLayer()) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">      if (MainApplication.getLayerManager().getEditLayer() != null) {</span>
<span class="nc" id="L485">        MainApplication.getLayerManager().getEditLayer().data.addDataSetListener(DATASET_LISTENER);</span>
      }
<span class="nc bnc" id="L487" title="All 2 branches missed.">      if (e.getPreviousEditLayer() != null) {</span>
<span class="nc" id="L488">        e.getPreviousEditLayer().data.removeDataSetListener(DATASET_LISTENER);</span>
      }
    }
<span class="fc" id="L491">  }</span>

  @Override
  public void visitBoundingBox(BoundingXYVisitor v) {
<span class="fc" id="L495">  }</span>

  /* (non-Javadoc)
   * @see org.openstreetmap.josm.plugins.mapillary.MapillaryDataListener#imagesAdded()
   */
  @Override
  public void imagesAdded() {
<span class="fc" id="L502">    updateNearestImages();</span>
<span class="fc" id="L503">  }</span>

  /* (non-Javadoc)
   * @see org.openstreetmap.josm.plugins.mapillary.MapillaryDataListener#selectedImageChanged(org.openstreetmap.josm.plugins.mapillary.MapillaryAbstractImage, org.openstreetmap.josm.plugins.mapillary.MapillaryAbstractImage)
   */
  @Override
  public void selectedImageChanged(MapillaryAbstractImage oldImage, MapillaryAbstractImage newImage) {
<span class="nc" id="L510">    updateNearestImages();</span>
<span class="nc" id="L511">  }</span>

  /**
   * Returns the closest images belonging to a different sequence and
   * different from the specified target image.
   *
   * @param target the image for which you want to find the nearest other images
   * @param limit the maximum length of the returned array
   * @return An array containing the closest images belonging to different sequences sorted by distance from target.
   */
  private MapillaryImage[] getNearestImagesFromDifferentSequences(MapillaryAbstractImage target, int limit) {
<span class="nc" id="L522">    return data.getSequences().parallelStream()</span>
<span class="nc bnc" id="L523" title="All 4 branches missed.">      .filter(seq -&gt; seq.getKey() != null &amp;&amp; !seq.getKey().equals(target.getSequence().getKey()))</span>
<span class="nc" id="L524">      .map(seq -&gt; { // Maps sequence to image from sequence that is nearest to target</span>
<span class="nc" id="L525">        Optional&lt;MapillaryAbstractImage&gt; resImg = seq.getImages().parallelStream()</span>
<span class="nc bnc" id="L526" title="All 4 branches missed.">          .filter(img -&gt; img instanceof MapillaryImage &amp;&amp; img.isVisible())</span>
<span class="nc" id="L527">          .sorted(new NearestImgToTargetComparator(target))</span>
<span class="nc" id="L528">          .findFirst();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        return resImg.isPresent() ? resImg.get() : null;</span>
      })
<span class="nc" id="L531">      .filter(img -&gt; // Filters out images too far away from target</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        img != null &amp;&amp;</span>
<span class="nc" id="L533">        img.getMovingLatLon().greatCircleDistance(target.getMovingLatLon())</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">          &lt; MapillaryProperties.SEQUENCE_MAX_JUMP_DISTANCE.get()</span>
       )
<span class="nc" id="L536">      .sorted(new NearestImgToTargetComparator(target))</span>
<span class="nc" id="L537">      .limit(limit)</span>
<span class="nc" id="L538">      .toArray(MapillaryImage[]::new);</span>
  }

  private synchronized void updateNearestImages() {
<span class="fc" id="L542">    final MapillaryAbstractImage selected = data.getSelectedImage();</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">    if (selected != null) {</span>
<span class="nc" id="L544">      nearestImages = getNearestImagesFromDifferentSequences(selected, 2);</span>
    } else {
<span class="fc" id="L546">      nearestImages = new MapillaryImage[0];</span>
    }
<span class="fc bfc" id="L548" title="All 2 branches covered.">    if (MainApplication.isDisplayingMapView()) {</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">      MapillaryMainDialog.getInstance().redButton.setEnabled(nearestImages.length &gt;= 1);</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">      MapillaryMainDialog.getInstance().blueButton.setEnabled(nearestImages.length &gt;= 2);</span>
    }
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">    if (nearestImages.length &gt;= 1) {</span>
<span class="nc" id="L553">      CacheUtils.downloadPicture(nearestImages[0]);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">      if (nearestImages.length &gt;= 2) {</span>
<span class="nc" id="L555">        CacheUtils.downloadPicture(nearestImages[1]);</span>
      }
    }
<span class="fc" id="L558">  }</span>

  /**
   * Action used to delete images.
   *
   * @author nokutu
   */
<span class="fc" id="L565">  private class DeleteImageAction extends AbstractAction {</span>

    private static final long serialVersionUID = -982809854631863962L;

    @Override
    public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">      if (instance != null)</span>
<span class="nc" id="L572">        MapillaryRecord.getInstance().addCommand(</span>
<span class="nc" id="L573">          new CommandDelete(getData().getMultiSelectedImages()));</span>
<span class="nc" id="L574">    }</span>
  }

  private static class NearestImgToTargetComparator implements Comparator&lt;MapillaryAbstractImage&gt; {
    private final MapillaryAbstractImage target;

<span class="nc" id="L580">    public NearestImgToTargetComparator(MapillaryAbstractImage target) {</span>
<span class="nc" id="L581">      this.target = target;</span>
<span class="nc" id="L582">    }</span>
    /* (non-Javadoc)
     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
     */
    @Override
    public int compare(MapillaryAbstractImage img1, MapillaryAbstractImage img2) {
<span class="nc" id="L588">      return (int) Math.signum(</span>
<span class="nc" id="L589">        img1.getMovingLatLon().greatCircleDistance(target.getMovingLatLon()) -</span>
<span class="nc" id="L590">        img2.getMovingLatLon().greatCircleDistance(target.getMovingLatLon())</span>
      );
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>