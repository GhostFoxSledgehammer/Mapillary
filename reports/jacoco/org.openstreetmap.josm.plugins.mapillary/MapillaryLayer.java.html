<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapillaryLayer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapillary</a> &gt; <a href="index.source.html" class="el_package">org.openstreetmap.josm.plugins.mapillary</a> &gt; <span class="el_source">MapillaryLayer.java</span></div><h1>MapillaryLayer.java</h1><pre class="source lang-java linenums">// License: GPL. For details, see LICENSE file.
package org.openstreetmap.josm.plugins.mapillary;

import static org.openstreetmap.josm.tools.I18n.marktr;
import static org.openstreetmap.josm.tools.I18n.tr;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.TexturePaint;
import java.awt.event.ActionEvent;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.image.BufferedImage;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.Icon;
import javax.swing.JComponent;
import javax.swing.KeyStroke;

import org.openstreetmap.josm.Main;
import org.openstreetmap.josm.data.Bounds;
import org.openstreetmap.josm.data.coor.LatLon;
import org.openstreetmap.josm.data.osm.event.AbstractDatasetChangedEvent;
import org.openstreetmap.josm.data.osm.event.DataChangedEvent;
import org.openstreetmap.josm.data.osm.event.DataSetListener;
import org.openstreetmap.josm.data.osm.event.NodeMovedEvent;
import org.openstreetmap.josm.data.osm.event.PrimitivesAddedEvent;
import org.openstreetmap.josm.data.osm.event.PrimitivesRemovedEvent;
import org.openstreetmap.josm.data.osm.event.RelationMembersChangedEvent;
import org.openstreetmap.josm.data.osm.event.TagsChangedEvent;
import org.openstreetmap.josm.data.osm.event.WayNodesChangedEvent;
import org.openstreetmap.josm.data.osm.visitor.BoundingXYVisitor;
import org.openstreetmap.josm.data.preferences.ColorProperty;
import org.openstreetmap.josm.gui.MapView;
import org.openstreetmap.josm.gui.NavigatableComponent;
import org.openstreetmap.josm.gui.dialogs.LayerListDialog;
import org.openstreetmap.josm.gui.dialogs.LayerListPopup;
import org.openstreetmap.josm.gui.layer.AbstractModifiableLayer;
import org.openstreetmap.josm.gui.layer.Layer;
import org.openstreetmap.josm.gui.layer.MainLayerManager.ActiveLayerChangeEvent;
import org.openstreetmap.josm.gui.layer.MainLayerManager.ActiveLayerChangeListener;
import org.openstreetmap.josm.plugins.mapillary.cache.CacheUtils;
import org.openstreetmap.josm.plugins.mapillary.gui.MapillaryChangesetDialog;
import org.openstreetmap.josm.plugins.mapillary.gui.MapillaryFilterDialog;
import org.openstreetmap.josm.plugins.mapillary.gui.MapillaryMainDialog;
import org.openstreetmap.josm.plugins.mapillary.history.MapillaryRecord;
import org.openstreetmap.josm.plugins.mapillary.history.commands.CommandDelete;
import org.openstreetmap.josm.plugins.mapillary.io.download.MapillaryDownloader;
import org.openstreetmap.josm.plugins.mapillary.io.download.MapillaryDownloader.DOWNLOAD_MODE;
import org.openstreetmap.josm.plugins.mapillary.mode.AbstractMode;
import org.openstreetmap.josm.plugins.mapillary.mode.JoinMode;
import org.openstreetmap.josm.plugins.mapillary.mode.SelectMode;
import org.openstreetmap.josm.plugins.mapillary.utils.MapViewGeometryUtil;
import org.openstreetmap.josm.plugins.mapillary.utils.MapillaryColorScheme;
import org.openstreetmap.josm.plugins.mapillary.utils.MapillaryUtils;

/**
 * This class represents the layer shown in JOSM. There can only exist one
 * instance of this object.
 *
 * @author nokutu
 */
public final class MapillaryLayer extends AbstractModifiableLayer implements
  DataSetListener, ActiveLayerChangeListener {

  /** Maximum distance for the red/blue lines. */
<span class="fc" id="L74">  public static final int SEQUENCE_MAX_JUMP_DISTANCE = Main.pref.getInteger(</span>
    &quot;mapillary.sequence-max-jump-distance&quot;, 100);

  /** The radius of the image marker */
  private static final int IMG_MARKER_RADIUS = 7;
  /** The radius of the circular sector that indicates the camera angle */
  private static final int CA_INDICATOR_RADIUS = 15;
  /** The angle of the circular sector that indicates the camera angle */
  private static final int CA_INDICATOR_ANGLE = 40;
  /** Length of the edge of the small sign, which indicates that traffic signs have been found in an image. */
  private static final int TRAFFIC_SIGN_SIZE = 6;
  /** A third of the height of the sign, for easier calculations */
<span class="fc" id="L86">  private static final double TRAFFIC_SIGN_HEIGHT_3RD = Math.sqrt(</span>
<span class="fc" id="L87">    Math.pow(TRAFFIC_SIGN_SIZE, 2) - Math.pow(TRAFFIC_SIGN_SIZE / 2d, 2)</span>
  ) / 3;

  /** If the download is in semiautomatic during this object lifetime. */
  public boolean tempSemiautomatic;

  /** Unique instance of the class. */
  private static MapillaryLayer instance;
  /** The image pointed by the blue line. */
  private MapillaryImage blue;
  /** The image pointed by the red line. */
  private MapillaryImage red;
  /** {@link MapillaryData} object that stores the database. */
  private final MapillaryData data;

  /** Mode of the layer. */
  public AbstractMode mode;

  private volatile TexturePaint hatched;
<span class="fc" id="L106">  private final MapillaryLocationChangeset locationChangeset = new MapillaryLocationChangeset();</span>

  private MapillaryLayer() {
<span class="fc" id="L109">    super(tr(&quot;Mapillary Images&quot;));</span>
<span class="fc" id="L110">    this.data = new MapillaryData();</span>
<span class="fc" id="L111">  }</span>

  /**
   * Initializes the Layer.
   */
  private void init() {
<span class="pc bpc" id="L117" title="3 of 4 branches missed.">    if (Main.main != null &amp;&amp; Main.map.mapView != null) {</span>
<span class="nc" id="L118">      setMode(new SelectMode());</span>
<span class="nc" id="L119">      Main.getLayerManager().addLayer(this);</span>
<span class="nc" id="L120">      Main.getLayerManager().addActiveLayerChangeListener(this);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      if (Main.getLayerManager().getEditLayer() != null) {</span>
<span class="nc" id="L122">        Main.getLayerManager().getEditLayer().data.addDataSetListener(this);</span>
      }
<span class="nc bnc" id="L124" title="All 2 branches missed.">      if (MapillaryDownloader.getMode() == DOWNLOAD_MODE.OSM_AREA) {</span>
<span class="nc" id="L125">        MapillaryDownloader.downloadOSMArea();</span>
      }
<span class="nc bnc" id="L127" title="All 2 branches missed.">      if (MapillaryDownloader.getMode() == DOWNLOAD_MODE.VISIBLE_AREA) {</span>
<span class="nc" id="L128">        this.mode.zoomChanged();</span>
      }
    }
    // Does not execute when in headless mode
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    if (MapillaryPlugin.getExportMenu() != null) {</span>
<span class="nc" id="L133">      MapillaryPlugin.setMenuEnabled(MapillaryPlugin.getExportMenu(), true);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      if (!MapillaryMainDialog.getInstance().isShowing()) {</span>
<span class="nc" id="L135">        MapillaryMainDialog.getInstance().getButton().doClick();</span>
      }
    }
<span class="fc" id="L138">    createHatchTexture();</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (Main.main != null) {</span>
<span class="nc" id="L140">      MapillaryMainDialog.getInstance()</span>
<span class="nc" id="L141">        .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)</span>
<span class="nc" id="L142">        .put(KeyStroke.getKeyStroke(&quot;DELETE&quot;), &quot;MapillaryDel&quot;);</span>
<span class="nc" id="L143">      MapillaryMainDialog.getInstance().getActionMap()</span>
<span class="nc" id="L144">        .put(&quot;MapillaryDel&quot;, new DeleteImageAction());</span>

<span class="nc" id="L146">      MapillaryData.dataUpdated();</span>
<span class="nc" id="L147">      getLocationChangeset().addChangesetListener(MapillaryChangesetDialog.getInstance());</span>
    }
<span class="fc" id="L149">  }</span>

  /**
   * Changes the mode the the given one.
   *
   * @param mode The mode that is going to be activated.
   */
  public void setMode(AbstractMode mode) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (this.mode != null) {</span>
<span class="nc" id="L158">      Main.map.mapView.removeMouseListener(this.mode);</span>
<span class="nc" id="L159">      Main.map.mapView.removeMouseMotionListener(this.mode);</span>
<span class="nc" id="L160">      NavigatableComponent.removeZoomChangeListener(this.mode);</span>
    }
<span class="nc" id="L162">    this.mode = mode;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (mode != null) {</span>
<span class="nc" id="L164">      Main.map.mapView.setNewCursor(mode.cursor, this);</span>
<span class="nc" id="L165">      Main.map.mapView.addMouseListener(mode);</span>
<span class="nc" id="L166">      Main.map.mapView.addMouseMotionListener(mode);</span>
<span class="nc" id="L167">      NavigatableComponent.addZoomChangeListener(mode);</span>
<span class="nc" id="L168">      MapillaryUtils.updateHelpText();</span>
    }
<span class="nc" id="L170">  }</span>

  /**
   * Clears the unique instance of this class.
   */
  public static void clearInstance() {
<span class="fc" id="L176">    instance = null;</span>
<span class="fc" id="L177">  }</span>

  /**
   * Returns the unique instance of this class.
   *
   * @return The unique instance of this class.
   */
  public static synchronized MapillaryLayer getInstance() {
<span class="fc bfc" id="L185" title="All 2 branches covered.">    if (instance == null) {</span>
<span class="fc" id="L186">      instance = new MapillaryLayer();</span>
<span class="fc" id="L187">      instance.init();</span>
    }
<span class="fc" id="L189">    return instance;</span>
  }

  /**
   * @return if the unique instance of this layer is currently instantiated
   */
  public static boolean hasInstance() {
<span class="fc bfc" id="L196" title="All 2 branches covered.">    return instance != null;</span>
  }

  /**
   * Returns the {@link MapillaryData} object, which acts as the database of the
   * Layer.
   *
   * @return The {@link MapillaryData} object that stores the database.
   */
  public MapillaryData getData() {
<span class="fc" id="L206">    return this.data;</span>
  }

  /**
   * Returns the {@link MapillaryLocationChangeset} object, which acts as the database of the
   * Layer.
   *
   * @return The {@link MapillaryData} object that stores the database.
   */
  public MapillaryLocationChangeset getLocationChangeset() {
<span class="fc" id="L216">    return locationChangeset;</span>
  }

  /**
   * @return The image that is linked to the current image with a blue line
   */
  public MapillaryImage getBlue() {
<span class="nc" id="L223">    return blue;</span>
  }

  /**
   * @return The image that is linked to the current image with a blue line
   */
  public MapillaryImage getRed() {
<span class="nc" id="L230">    return red;</span>
  }

  @Override
  public void destroy() {
<span class="nc" id="L235">    setMode(null);</span>
<span class="nc" id="L236">    MapillaryRecord.getInstance().reset();</span>
<span class="nc" id="L237">    AbstractMode.resetThread();</span>
<span class="nc" id="L238">    MapillaryDownloader.stopAll();</span>
<span class="nc" id="L239">    MapillaryMainDialog.getInstance().setImage(null);</span>
<span class="nc" id="L240">    MapillaryMainDialog.getInstance().updateImage();</span>
<span class="nc" id="L241">    MapillaryPlugin.setMenuEnabled(MapillaryPlugin.getExportMenu(), false);</span>
<span class="nc" id="L242">    MapillaryPlugin.setMenuEnabled(MapillaryPlugin.getZoomMenu(), false);</span>
<span class="nc" id="L243">    Main.map.mapView.removeMouseListener(this.mode);</span>
<span class="nc" id="L244">    Main.map.mapView.removeMouseMotionListener(this.mode);</span>
<span class="nc" id="L245">    Main.getLayerManager().removeActiveLayerChangeListener(this);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (Main.getLayerManager().getEditLayer() != null)</span>
<span class="nc" id="L247">      Main.getLayerManager().getEditLayer().data.removeDataSetListener(this);</span>
<span class="nc" id="L248">    clearInstance();</span>
<span class="nc" id="L249">    super.destroy();</span>
<span class="nc" id="L250">  }</span>

  @Override
  public boolean isModified() {
<span class="nc" id="L254">    return this.data.getImages().parallelStream().anyMatch(MapillaryAbstractImage::isModified);</span>
  }

  @Override
  public void setVisible(boolean visible) {
<span class="fc" id="L259">    super.setVisible(visible);</span>
<span class="fc" id="L260">    this.data.getImages().parallelStream().forEach(img -&gt; img.setVisible(visible));</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    if (Main.map != null) {</span>
<span class="nc" id="L262">      MapillaryFilterDialog.getInstance().refresh();</span>
    }
<span class="fc" id="L264">  }</span>

  /**
   * Replies background color for downloaded areas.
   *
   * @return background color for downloaded areas. Black by default.
   */
  private static Color getBackgroundColor() {
<span class="fc" id="L272">    return new ColorProperty(marktr(&quot;background&quot;), Color.BLACK).get();</span>
  }

  /**
   * Replies background color for non-downloaded areas.
   *
   * @return background color for non-downloaded areas. Yellow by default.
   */
  private static Color getOutsideColor() {
<span class="fc" id="L281">    return new ColorProperty(marktr(&quot;outside downloaded area&quot;), Color.YELLOW).get();</span>
  }

  /**
   * Initialize the hatch pattern used to paint the non-downloaded area.
   */
  private void createHatchTexture() {
<span class="fc" id="L288">    BufferedImage bi = new BufferedImage(15, 15, BufferedImage.TYPE_INT_ARGB);</span>
<span class="fc" id="L289">    Graphics2D big = bi.createGraphics();</span>
<span class="fc" id="L290">    big.setColor(getBackgroundColor());</span>
<span class="fc" id="L291">    Composite comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f);</span>
<span class="fc" id="L292">    big.setComposite(comp);</span>
<span class="fc" id="L293">    big.fillRect(0, 0, 15, 15);</span>
<span class="fc" id="L294">    big.setColor(getOutsideColor());</span>
<span class="fc" id="L295">    big.drawLine(0, 15, 15, 0);</span>
<span class="fc" id="L296">    Rectangle r = new Rectangle(0, 0, 15, 15);</span>
<span class="fc" id="L297">    this.hatched = new TexturePaint(bi, r);</span>
<span class="fc" id="L298">  }</span>

  @Override
  public synchronized void paint(final Graphics2D g, final MapView mv, final Bounds box) {
<span class="nc" id="L302">    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (Main.getLayerManager().getActiveLayer() == this) {</span>
      // paint remainder
<span class="nc" id="L305">      g.setPaint(this.hatched);</span>
<span class="nc" id="L306">      g.fill(MapViewGeometryUtil.getNonDownloadedArea(mv, this.data.getBounds()));</span>
    }

    // Draw colored lines
<span class="nc" id="L310">    MapillaryMainDialog.getInstance().blueButton.setEnabled(false);</span>
<span class="nc" id="L311">    MapillaryMainDialog.getInstance().redButton.setEnabled(false);</span>
<span class="nc" id="L312">    blue = null;</span>
<span class="nc" id="L313">    red = null;</span>

    // Draw the blue and red line and enable/disable the buttons
<span class="nc bnc" id="L316" title="All 2 branches missed.">    if (this.data.getSelectedImage() != null) {</span>
<span class="nc" id="L317">      MapillaryImage[] closestImages = getClosestImagesFromDifferentSequences();</span>
<span class="nc" id="L318">      Point selected = mv.getPoint(this.data.getSelectedImage().getMovingLatLon());</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (closestImages[0] != null) {</span>
<span class="nc" id="L320">        blue = closestImages[0];</span>
<span class="nc" id="L321">        g.setColor(Color.BLUE);</span>
<span class="nc" id="L322">        final Point p = mv.getPoint(closestImages[0].getMovingLatLon());</span>
<span class="nc" id="L323">        g.draw(new Line2D.Double(p.getX(), p.getY(), selected.getX(), selected.getY()));</span>
<span class="nc" id="L324">        MapillaryMainDialog.getInstance().blueButton.setEnabled(true);</span>
      }
<span class="nc bnc" id="L326" title="All 2 branches missed.">      if (closestImages[1] != null) {</span>
<span class="nc" id="L327">        red = closestImages[1];</span>
<span class="nc" id="L328">        g.setColor(Color.RED);</span>
<span class="nc" id="L329">        final Point p = mv.getPoint(closestImages[1].getMovingLatLon());</span>
<span class="nc" id="L330">        g.draw(new Line2D.Double(p.getX(), p.getY(), selected.getX(), selected.getY()));</span>
<span class="nc" id="L331">        MapillaryMainDialog.getInstance().redButton.setEnabled(true);</span>
      }
    }
    // Draw sequence line
<span class="nc" id="L335">    g.setStroke(new BasicStroke(2));</span>
<span class="nc" id="L336">    final MapillaryAbstractImage selectedImage = getData().getSelectedImage();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">    for (MapillarySequence seq : getData().getSequences()) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">      if (seq.getImages().contains(selectedImage)) {</span>
<span class="nc" id="L339">        g.setColor(</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">          seq.getKey() == null ? MapillaryColorScheme.SEQ_IMPORTED_SELECTED : MapillaryColorScheme.SEQ_SELECTED</span>
        );
      } else {
<span class="nc" id="L343">        g.setColor(</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">          seq.getKey() == null ? MapillaryColorScheme.SEQ_IMPORTED_UNSELECTED : MapillaryColorScheme.SEQ_UNSELECTED</span>
        );
      }
<span class="nc" id="L347">      g.draw(MapViewGeometryUtil.getSequencePath(mv, seq));</span>
<span class="nc" id="L348">    }</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">    for (MapillaryAbstractImage imageAbs : this.data.getImages()) {</span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">      if (imageAbs.isVisible() &amp;&amp; Main.map.mapView.contains(Main.map.mapView.getPoint(imageAbs.getMovingLatLon()))) {</span>
<span class="nc" id="L351">        drawImageMarker(g, imageAbs);</span>
      }
<span class="nc" id="L353">    }</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">    if (this.mode instanceof JoinMode) {</span>
<span class="nc" id="L355">      this.mode.paint(g, mv, box);</span>
    }
<span class="nc" id="L357">  }</span>

  /**
   * Draws an image marker onto the given Graphics context.
   * @param g the Graphics context
   * @param img the image to be drawn onto the Graphics context
   */
  private void drawImageMarker(final Graphics2D g, final MapillaryAbstractImage img) {
<span class="nc bnc" id="L365" title="All 4 branches missed.">    if (img == null || img.getLatLon() == null) {</span>
<span class="nc" id="L366">      Main.warn(&quot;An image is not painted, because it is null or has no LatLon!&quot;);</span>
<span class="nc" id="L367">      return;</span>
    }
<span class="nc" id="L369">    final MapillaryAbstractImage selectedImg = getData().getSelectedImage();</span>
<span class="nc" id="L370">    final Point p = Main.map.mapView.getPoint(img.getMovingLatLon());</span>

    // Determine colors
    final Color markerC;
    final Color directionC;
<span class="nc bnc" id="L375" title="All 4 branches missed.">    if (selectedImg != null &amp;&amp; getData().getMultiSelectedImages().contains(img)) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">      markerC = img instanceof MapillaryImportedImage</span>
        ? MapillaryColorScheme.SEQ_IMPORTED_HIGHLIGHTED
        : MapillaryColorScheme.SEQ_HIGHLIGHTED;
<span class="nc bnc" id="L379" title="All 2 branches missed.">      directionC = img instanceof MapillaryImportedImage</span>
        ? MapillaryColorScheme.SEQ_IMPORTED_HIGHLIGHTED_CA
        : MapillaryColorScheme.SEQ_HIGHLIGHTED_CA;
<span class="nc bnc" id="L382" title="All 6 branches missed.">    } else if (selectedImg != null &amp;&amp; selectedImg.getSequence() != null &amp;&amp; selectedImg.getSequence().equals(img.getSequence())) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      markerC = img instanceof MapillaryImportedImage</span>
        ? MapillaryColorScheme.SEQ_IMPORTED_SELECTED
        : MapillaryColorScheme.SEQ_SELECTED;
<span class="nc bnc" id="L386" title="All 2 branches missed.">      directionC = img instanceof MapillaryImportedImage</span>
        ? MapillaryColorScheme.SEQ_IMPORTED_SELECTED_CA
        : MapillaryColorScheme.SEQ_SELECTED_CA;
    } else {
<span class="nc bnc" id="L390" title="All 2 branches missed.">      markerC = img instanceof MapillaryImportedImage</span>
        ? MapillaryColorScheme.SEQ_IMPORTED_UNSELECTED
        : MapillaryColorScheme.SEQ_UNSELECTED;
<span class="nc bnc" id="L393" title="All 2 branches missed.">      directionC = img instanceof MapillaryImportedImage</span>
        ? MapillaryColorScheme.SEQ_IMPORTED_UNSELECTED_CA
        : MapillaryColorScheme.SEQ_UNSELECTED_CA;
    }

    // Paint direction indicator
<span class="nc" id="L399">    g.setColor(directionC);</span>
<span class="nc" id="L400">    g.fillArc(p.x - CA_INDICATOR_RADIUS, p.y - CA_INDICATOR_RADIUS, 2 * CA_INDICATOR_RADIUS, 2 * CA_INDICATOR_RADIUS, (int) (90 - img.getMovingCa() - CA_INDICATOR_ANGLE / 2), CA_INDICATOR_ANGLE);</span>
    // Paint image marker
<span class="nc" id="L402">    g.setColor(markerC);</span>
<span class="nc" id="L403">    g.fillOval(p.x - IMG_MARKER_RADIUS, p.y - IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS);</span>

    // Paint highlight for selected or highlighted images
<span class="nc bnc" id="L406" title="All 4 branches missed.">    if (img.equals(getData().getHighlightedImage()) || getData().getMultiSelectedImages().contains(img)) {</span>
<span class="nc" id="L407">      g.setColor(Color.WHITE);</span>
<span class="nc" id="L408">      g.setStroke(new BasicStroke(2));</span>
<span class="nc" id="L409">      g.drawOval(p.x - IMG_MARKER_RADIUS, p.y - IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS);</span>
    }


<span class="nc bnc" id="L413" title="All 4 branches missed.">    if (img instanceof MapillaryImage &amp;&amp; !((MapillaryImage) img).getSigns().isEmpty()) {</span>
<span class="nc" id="L414">      Path2D trafficSign = new Path2D.Double();</span>
<span class="nc" id="L415">      trafficSign.moveTo(p.getX() - TRAFFIC_SIGN_SIZE / 2d, p.getY() - TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L416">      trafficSign.lineTo(p.getX() + TRAFFIC_SIGN_SIZE / 2d, p.getY() - TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L417">      trafficSign.lineTo(p.getX(), p.getY() + 2 * TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L418">      trafficSign.closePath();</span>
<span class="nc" id="L419">      g.setColor(Color.WHITE);</span>
<span class="nc" id="L420">      g.fill(trafficSign);</span>
<span class="nc" id="L421">      g.setStroke(new BasicStroke(1));</span>
<span class="nc" id="L422">      g.setColor(Color.RED);</span>
<span class="nc" id="L423">      g.draw(trafficSign);</span>
    }
<span class="nc" id="L425">  }</span>

  @Override
  public Icon getIcon() {
<span class="fc" id="L429">    return MapillaryPlugin.ICON16;</span>
  }

  @Override
  public boolean isMergable(Layer other) {
<span class="fc" id="L434">    return false;</span>
  }

  @Override
  public void mergeFrom(Layer from) {
<span class="fc" id="L439">    throw new UnsupportedOperationException(</span>
      &quot;This layer does not support merging yet&quot;);
  }

  @Override
  public Action[] getMenuEntries() {
<span class="nc" id="L445">    return new Action[]{</span>
<span class="nc" id="L446">      LayerListDialog.getInstance().createShowHideLayerAction(),</span>
<span class="nc" id="L447">      LayerListDialog.getInstance().createDeleteLayerAction(),</span>
      new LayerListPopup.InfoAction(this)
    };
  }

  /**
   * Returns the 2 closest images belonging to a different sequence and
   * different from the currently selected one.
   *
   * @return An array of length 2 containing the two closest images belonging to
   * different sequences.
   */
  private MapillaryImage[] getClosestImagesFromDifferentSequences() {
<span class="nc bnc" id="L460" title="All 2 branches missed.">    if (!(this.data.getSelectedImage() instanceof MapillaryImage))</span>
<span class="nc" id="L461">      return new MapillaryImage[]{null, null};</span>
<span class="nc" id="L462">    MapillaryImage selected = (MapillaryImage) this.data.getSelectedImage();</span>
<span class="nc" id="L463">    MapillaryImage[] ret = new MapillaryImage[2];</span>
<span class="nc" id="L464">    double[] distances = {</span>
      SEQUENCE_MAX_JUMP_DISTANCE,
      SEQUENCE_MAX_JUMP_DISTANCE
    };
<span class="nc" id="L468">    LatLon selectedCoords = this.data.getSelectedImage().getMovingLatLon();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">    for (MapillaryAbstractImage imagePrev : this.data.getImages()) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">      if (!(imagePrev instanceof MapillaryImage))</span>
<span class="nc" id="L471">        continue;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">      if (!imagePrev.isVisible())</span>
<span class="nc" id="L473">        continue;</span>
<span class="nc" id="L474">      MapillaryImage image = (MapillaryImage) imagePrev;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      if (image.getMovingLatLon().greatCircleDistance(selectedCoords) &lt; SEQUENCE_MAX_JUMP_DISTANCE</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        &amp;&amp; selected.getSequence() != image.getSequence()) {</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">        if (</span>
          ret[0] == null &amp;&amp; ret[1] == null
<span class="nc bnc" id="L479" title="All 4 branches missed.">            || image.getMovingLatLon().greatCircleDistance(selectedCoords) &lt; distances[0]</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">            &amp;&amp; (ret[1] == null || image.getSequence() != ret[1].getSequence())</span>
          ) {
<span class="nc" id="L482">          ret[0] = image;</span>
<span class="nc" id="L483">          distances[0] = image.getMovingLatLon().greatCircleDistance(selectedCoords);</span>
<span class="nc bnc" id="L484" title="All 4 branches missed.">        } else if ((ret[1] == null || image.getMovingLatLon().greatCircleDistance(</span>
          selectedCoords) &lt; distances[1])
<span class="nc bnc" id="L486" title="All 2 branches missed.">          &amp;&amp; image.getSequence() != ret[0].getSequence()) {</span>
<span class="nc" id="L487">          ret[1] = image;</span>
<span class="nc" id="L488">          distances[1] = image.getMovingLatLon().greatCircleDistance(selectedCoords);</span>
        }
      }
<span class="nc" id="L491">    }</span>
    // Predownloads the thumbnails
<span class="nc bnc" id="L493" title="All 2 branches missed.">    if (ret[0] != null)</span>
<span class="nc" id="L494">      CacheUtils.downloadPicture(ret[0]);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">    if (ret[1] != null)</span>
<span class="nc" id="L496">      CacheUtils.downloadPicture(ret[1]);</span>
<span class="nc" id="L497">    return ret;</span>
  }

  @Override
  public Object getInfoComponent() {
<span class="fc" id="L502">    return tr(&quot;Mapillary layer&quot;) +</span>
      '\n' +
<span class="fc" id="L504">      tr(&quot;Total images:&quot;) +</span>
      ' ' +
<span class="fc" id="L506">      this.data.size() +</span>
      '\n';
  }

  @Override
  public String getToolTipText() {
<span class="nc" id="L512">    return this.data.size() + (' ' + tr(&quot;images&quot;));</span>
  }

  @Override
  public void activeOrEditLayerChanged(ActiveLayerChangeEvent e) {
<span class="nc bnc" id="L517" title="All 2 branches missed.">    if (Main.getLayerManager().getActiveLayer() == this) {</span>
<span class="nc" id="L518">      MapillaryUtils.updateHelpText();</span>
    }
<span class="nc bnc" id="L520" title="All 2 branches missed.">    MapillaryPlugin.setMenuEnabled(MapillaryPlugin.getJoinMenu(), Main.getLayerManager().getActiveLayer() == this);</span>

<span class="nc bnc" id="L522" title="All 2 branches missed.">    if (Main.getLayerManager().getEditLayer() != e.getPreviousEditLayer()) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">      if (Main.getLayerManager().getEditLayer() != null) {</span>
<span class="nc" id="L524">        Main.getLayerManager().getEditLayer().data.addDataSetListener(this);</span>
      }
<span class="nc bnc" id="L526" title="All 2 branches missed.">      if (e.getPreviousEditLayer() != null) {</span>
<span class="nc" id="L527">        e.getPreviousEditLayer().data.removeDataSetListener(this);</span>
      }
    }
<span class="nc" id="L530">  }</span>

  @Override
  public void dataChanged(DataChangedEvent event) {
    // When more data is downloaded, a delayed update is thrown, in order to
    // wait for the data bounds to be set.
<span class="nc" id="L536">    Main.worker.submit(new DelayedDownload());</span>
<span class="nc" id="L537">  }</span>

  @Override
  public void primitivesAdded(PrimitivesAddedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L542">  }</span>

  @Override
  public void primitivesRemoved(PrimitivesRemovedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L547">  }</span>

  @Override
  public void tagsChanged(TagsChangedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L552">  }</span>

  @Override
  public void nodeMoved(NodeMovedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L557">  }</span>

  @Override
  public void wayNodesChanged(WayNodesChangedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L562">  }</span>

  @Override
  public void relationMembersChanged(RelationMembersChangedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L567">  }</span>

  @Override
  public void otherDatasetChange(AbstractDatasetChangedEvent event) {
    // Required by DataSetListener. But we are not interested in what changed, only _that_ something changed.
<span class="nc" id="L572">  }</span>

  @Override
  public void visitBoundingBox(BoundingXYVisitor v) {
<span class="nc" id="L576">  }</span>

  /**
   * Threads that runs a delayed Mapillary download.
   *
   * @author nokutu
   */
<span class="nc" id="L583">  private static class DelayedDownload extends Thread {</span>

    @Override
    public void run() {
      try {
<span class="nc" id="L588">        sleep(1500);</span>
<span class="nc" id="L589">      } catch (InterruptedException e) {</span>
<span class="nc" id="L590">        Main.error(e);</span>
<span class="nc" id="L591">      }</span>
<span class="nc" id="L592">      MapillaryDownloader.downloadOSMArea();</span>
<span class="nc" id="L593">    }</span>
  }

  /**
   * Action used to delete images.
   *
   * @author nokutu
   */
<span class="nc" id="L601">  private class DeleteImageAction extends AbstractAction {</span>

    private static final long serialVersionUID = -982809854631863962L;

    @Override
    public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (instance != null)</span>
<span class="nc" id="L608">        MapillaryRecord.getInstance().addCommand(</span>
<span class="nc" id="L609">          new CommandDelete(getData().getMultiSelectedImages()));</span>
<span class="nc" id="L610">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>