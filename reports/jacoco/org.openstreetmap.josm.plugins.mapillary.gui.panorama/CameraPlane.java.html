<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CameraPlane.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapillary</a> &gt; <a href="index.source.html" class="el_package">org.openstreetmap.josm.plugins.mapillary.gui.panorama</a> &gt; <span class="el_source">CameraPlane.java</span></div><h1>CameraPlane.java</h1><pre class="source lang-java linenums">// License: GPL. For details, see LICENSE file.
package org.openstreetmap.josm.plugins.mapillary.gui.panorama;

import java.awt.Point;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.util.stream.IntStream;

public class CameraPlane {
  private final int width;
  private final int height;
  private final double distance;

  private Vector3D[][] vectors;
  private double theta;
  private double sinTheta;
  private double cosTheta;
  private double phi;
  private double sinPhi;
  private double cosPhi;

<span class="fc" id="L22">  public CameraPlane(int width, int height, double distance) {</span>
<span class="fc" id="L23">    this.width = width;</span>
<span class="fc" id="L24">    this.height = height;</span>
<span class="fc" id="L25">    this.distance = distance;</span>
<span class="fc" id="L26">    setRotation(0.0, 0.0);</span>
<span class="fc" id="L27">    vectors = new Vector3D[width][height];</span>
<span class="fc" id="L28">    IntStream.range(0, height).parallel().forEach(y -&gt; {</span>
<span class="fc" id="L29">      IntStream.range(0, width).parallel().forEach(x -&gt; {</span>
<span class="fc" id="L30">        vectors[x][y] = new Vector3D(x - width / 2d, y - height / 2d, distance).normalize();</span>
<span class="fc" id="L31">      });</span>
<span class="fc" id="L32">    });</span>
<span class="fc" id="L33">  }</span>

  /**
   * @param vector the vector for which the corresponding point on the camera plane will be returned
   * @return the point on the camera plane to which the given vector is mapped, nullable
   */
  public Point getPoint(final Vector3D vector) {
<span class="nc" id="L40">    final Vector3D rotatedVector = rotate(vector, -1);</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">    if (rotatedVector.getZ() &lt; 0) {</span>
<span class="nc" id="L42">      return null; // Ignores any points &quot;behind the back&quot;, so they don't get painted a second time on the other side of the sphere</span>
    }
<span class="nc" id="L44">    return new Point(</span>
<span class="nc" id="L45">      (int) Math.max(Integer.MIN_VALUE, Math.min(Integer.MAX_VALUE, Math.round(</span>
<span class="nc" id="L46">        rotatedVector.getX() / rotatedVector.getZ() * distance + width / 2d</span>
      ))),
<span class="nc" id="L48">      (int) Math.max(Integer.MIN_VALUE, Math.min(Integer.MAX_VALUE, Math.round(</span>
<span class="nc" id="L49">        rotatedVector.getY() / rotatedVector.getZ() * distance + height / 2d</span>
      )))
    );
  }

  Vector3D getVector3D(final Point p) {
    Vector3D res;
    try {
<span class="fc" id="L57">      res = rotate(vectors[p.x][p.y]);</span>
<span class="nc" id="L58">    } catch (Exception e) {</span>
<span class="nc" id="L59">      res = new Vector3D(0, 0, 1);</span>
<span class="fc" id="L60">    }</span>
<span class="fc" id="L61">    return res;</span>
  }

  /**
   * Set camera plane rotation by current plane position.
   * @param p Point within current plane.
   */
  public void setRotation(final Point p) {
<span class="nc" id="L69">    setRotation(getVector3D(p));</span>
<span class="nc" id="L70">  }</span>

  public void setRotationFromDelta(final Point from, final Point to) {
<span class="nc" id="L73">    Vector3D f1 = vectors[from.x][from.y];</span>
<span class="nc" id="L74">    Vector3D t1 = vectors[to.x][to.y];</span>
<span class="nc" id="L75">    double deltaTheta = Math.atan2(f1.getX(), f1.getZ()) - Math.atan2(t1.getX(), t1.getZ());</span>
<span class="nc" id="L76">    double deltaPhi = Math.atan2(f1.getY(), Math.sqrt(f1.getX() * f1.getX() + f1.getZ() * f1.getZ()))</span>
<span class="nc" id="L77">        - Math.atan2(t1.getY(), Math.sqrt(t1.getX() * t1.getX() + t1.getZ() * t1.getZ()));</span>
<span class="nc" id="L78">    double newTheta = theta + deltaTheta;</span>
<span class="nc" id="L79">    double newPhi = phi + deltaPhi;</span>
<span class="nc" id="L80">    setRotation(newTheta, newPhi);</span>
<span class="nc" id="L81">  }</span>

  /**
   * Set camera plane rotation by spherical vector.
   * @param vec vector pointing new view position.
   */
  public void setRotation(Vector3D vec) {
    double theta, phi;
    try {
<span class="fc" id="L90">      theta = Math.atan2(vec.getX(), vec.getZ());</span>
<span class="fc" id="L91">      phi = Math.atan2(vec.getY(), Math.sqrt(vec.getX() * vec.getX() + vec.getZ() * vec.getZ()));</span>
<span class="nc" id="L92">    } catch (Exception e) {</span>
<span class="nc" id="L93">      theta = 0;</span>
<span class="nc" id="L94">      phi = 0;</span>
<span class="fc" id="L95">    }</span>
<span class="fc" id="L96">    setRotation(theta, phi);</span>
<span class="fc" id="L97">  }</span>

  Vector3D getRotation() {
<span class="fc" id="L100">    return new Vector3D(sinTheta, sinPhi, cosPhi * cosTheta);</span>
  }

  synchronized void setRotation(double theta, double phi) {
<span class="fc" id="L104">    this.theta = theta;</span>
<span class="fc" id="L105">    this.sinTheta = Math.sin(theta);</span>
<span class="fc" id="L106">    this.cosTheta = Math.cos(theta);</span>
<span class="fc" id="L107">    this.phi = phi;</span>
<span class="fc" id="L108">    this.sinPhi = Math.sin(phi);</span>
<span class="fc" id="L109">    this.cosPhi = Math.cos(phi);</span>
<span class="fc" id="L110">  }</span>

  private Vector3D rotate(final Vector3D vec) {
<span class="fc" id="L113">    return rotate(vec, 1);</span>
  }

  private Vector3D rotate(final Vector3D vec, final int rotationFactor) {
    double vecX, vecY, vecZ;
<span class="fc" id="L118">    vecZ = vec.getZ() * cosPhi - vec.getY() * sinPhi;</span>
<span class="fc" id="L119">    vecY = vec.getZ() * sinPhi + vec.getY() * cosPhi;</span>
<span class="fc" id="L120">    vecX = vecZ * sinTheta * rotationFactor + vec.getX() * cosTheta;</span>
<span class="fc" id="L121">    vecZ = vecZ * cosTheta - vec.getX() * sinTheta * rotationFactor;</span>
<span class="fc" id="L122">    return new Vector3D(vecX, vecY, vecZ);</span>
  }

  public void mapping(BufferedImage sourceImage, BufferedImage targetImage) {
<span class="nc" id="L126">    IntStream.range(0, targetImage.getHeight()).parallel().forEach(y -&gt; {</span>
<span class="nc" id="L127">      IntStream.range(0, targetImage.getWidth()).forEach(x -&gt; {</span>
<span class="nc" id="L128">        final Vector3D vec = getVector3D(new Point(x, y));</span>
<span class="nc" id="L129">        final Point2D.Double p = UVMapping.getTextureCoordinate(vec);</span>
<span class="nc" id="L130">        targetImage.setRGB(x, y,</span>
<span class="nc" id="L131">            sourceImage.getRGB((int) (p.x * (sourceImage.getWidth() - 1)), (int) (p.y * (sourceImage.getHeight() - 1)))</span>
        );
<span class="nc" id="L133">      });</span>
<span class="nc" id="L134">    });</span>
<span class="nc" id="L135">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>